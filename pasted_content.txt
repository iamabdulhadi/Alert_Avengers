create the following end to end project from scratch,  do a simulation run address all the loose ends and give me a executable project files in the form of a zip folder and ensure that the performance of the model is at least above 80%

Objective: Design and develop an AI-powered query system that can accurately translate natural language requests into functional SQL queries for database operations. This system will democratize data access for non-technical staff who need to retrieve financial transaction information but lack SQL expertise. Problem Statement: In the modern banking environment, financial analysts and customer service representatives frequently need to access transaction data to serve customers and make business decisions. However, many of these professionals lack technical SQL skills required to efficiently query banking databases. This creates bottlenecks in data access, delays, and increases dependency on specialized IT teams. Your task is to create a Generative AI solution that can address these issues. Core Functional Requirements: 1. Natural Language Understanding: The AI model must parse and understand natural language requests about banking transactions, accounts, customers, and branches. It should accurately interpret natural language descriptions of banking data needs. 2. SQL Query Generation: Convert natural language requests into correct, executable SQL queries for the bank’s relational database. The generated SQL queries must be syntactically correct and accurately reflect user intent for banking operations. 3. Supported SQL Operations: The system must support common SQL operations including SELECT, WHERE, JOIN, GROUP BY, and aggregation functions. 4. User-Friendly Output: Return relevant financial transaction information in a user-friendly format. 5. Conversational Ambiguity Resolution: Support follow-up questions in a conversational manner to resolve ambiguity. The system must handle ambiguity in natural language by requesting clarification when needed. 6. Contextual Understanding: Support contextual follow-up questions that reference previous queries, maintaining context across multiple conversation turns. Technical Implementation Requirements: 1. Database Engine: Use SQLite as the database engine for consistent evaluation across submissions. 2. Agent-Based Architecture: Implement an agent-based architecture using LangChain or LangGraph or any equivalent framework. 3. User Interface: Develop a Streamlit-based user interface or any equivalent UI framework for interaction with your solution. 4. Dependency Management: Use the uv package manager (preferred) or requirements.txt for Python dependency management. Include a setup.py or requirements.txt file with all dependencies listed. 5. Project Structure: Include a README.md with clear setup and execution instructions. 6. Security Measures: Properly handle sensitive financial data with appropriate security measures. Note: All technical requirements listed above are mandatory. Submission Requirements: 1. Local Execution: All code must run locally without requiring any third-party infrastructure. 2. Sample Data: Submissions must include a setup script that initializes the SQLite database with sample data. 3. Code Coverage: Include at least 60% of code coverage. 4. Design/Architectural Document: Submit a design/architectural document that includes: • Explanation of your SQL generation approach and why you chose it. • Description of how your agent architecture works. • Documentation about any challenges encountered and how they were addressed. • Inclusion of performance metrics on your test cases. • Highlighting of strengths and limitations of your approach. 5. GitHub Repository: Submit your code via a GitHub repository with clear documentation in the main branch. Evaluation Criteria: 1. Database Compatibility: Your solution should work with a database that includes tables and data shared via GitHub repository during the hackathon. 2. Functional Requirements Assessment: • SQL Translation Accuracy: Evaluates how accurately the system translates input into SQL queries. • Query Complexity Support: Assesses the ability to handle queries of varying complexity. • Ambiguity Resolution: Measures the system’s ability to identify and resolve unclear or vague inputs. • Contextual Understanding: Tests the system’s ability to maintain context across multiple conversation turns. 3. Technical Implementation Assessment: • Agent Architecture: Focuses on the design, reasoning capabilities, and state management of the agent. • SQL Generation Approach: Evaluates the efficiency and accuracy of the SQL generation strategy, with a focus on token minimization. • Code Quality & Structure: Reviews the organization, modularity, and adherence to design patterns. Automated Evaluation – Critical Reminder: The first level of evaluation is automated. This means: • The system scans your repository for files in specific folders. • If files are misplaced (e.g., source code in artifacts/ or demo video in code/), the evaluation may fail. • Incorrect folder placement can result in your submission being skipped or disqualified, even if the solution is complete and innovative. Avoid These Common Mistakes: • Committing all files to the root folder. • Renaming or restructuring the provided template. • Missing or incomplete README file. • Uploading video demos for longer than 10 minutes. Recommended Technology Stack (Optional but Encouraged): • Backend: Python 3.10+ • Database: SQLite (required) • AI/ML: LangChain or LangGraph with OpenAI API or local LLM integration • Frontend: Python Libraries for Building Interactive Apps (Streamlit/Gradio) • Package Manager: uv (optional but recommended) • Testing: Pytest, Unit tests • Version Control: Git/GitHub Note: While certain tools and frameworks are recommended, you are free to use any technology stack that best suits your team’s expertise and approach. Innovation and flexibility are encouraged. Validation and Loopholes Prevention: Before finalizing your solution, rigorously validate it against every point in this prompt. Ensure comprehensive coverage, unambiguous language, and precise instructions. Consider all edge cases and potential misinterpretations to prevent any omissions or loopholes. The goal is a robust, compliant, and high-quality solution that directly addresses all aspects of the challenge.

INclude a .txt file to give me steps 1 after another including commands end to end steps to execute this successfully. Also ensure that no matter who audits this there should not be any limitation or misses and no scope for hallucination
